"""
The driver file for confocal_browser.py
confocal_browser.py should not be edited by the user
confocal_browser.ui is generated by Qt Designer, and not to be text-edited
"""

import os
import sys
from PyQt5 import QtGui, QtCore
import pyqtgraph as pg
from pyModbusTCP.client import ModbusClient
from pyModbusTCP import utils
# from PyQt5.QtCore import QThread, SIGNAL
import numpy as np
import csv
import time
import datetime
import struct
import serial

import instruments.DAQmxAnalogInput
# import instruments as instr
import UHV_System


# This thing reroute the exception handling such that it does not close the GUI when an exception is thrown in PyQt5
def my_excepthook(type, value, tback):
    sys.__excepthook__(type, value, tback)


sys.excepthook = my_excepthook


def num2bits(num):
    return [int(num / 65536), int(num % 65536)]


def bits2num(bits):
    return bits[0]*65536 + bits[1]


def float2bits(num):
    return num2bits(utils.encode_ieee(num))


def bits2float(bits):
    return utils.decode_ieee(bits2num(bits))

# import ui files


class UHV_Gui(QtGui.QMainWindow, UHV_System.Ui_MainWindow):
    def __init__(self):
        # constructor from QMainWindow parent class
        super(self.__class__,self).__init__()
        # configure PyQTgraph to use white background
        pg.setConfigOption('background', 'w')
        pg.setConfigOption('foreground', 'k')
        # setupUi sits in exptdesign, as defined by Qt Designer
        self.setupUi(self)

        self.setFixedSize(self.size())
        # self.setWindowFlags(QtCore.Qt.WindowCloseButtonHint | QtCore.Qt.WindowMinimizeButtonHint)
        # self.setWindowFlags(QtCore.Qt.CustomizeWindowHint)
        self.setWindowFlags(QtCore.Qt.FramelessWindowHint)
        self.setAttribute(QtCore.Qt.WA_DeleteOnClose)
        # this will ensure that the application quits at the right time,
        # and that Qt has a chance to automatically delete all the children of the top-level window
        # before the python garbage-collector gets to work.
        # http://stackoverflow.com/questions/27131294/error-qobjectstarttimer-qtimer-can-only-be-used-with-threads-started-with-qt

        self.chkbox_AlwaysOnTop.stateChanged.connect(self.set_AlwaysOnTop)

        self.ion_pump = ModbusClient(host="192.168.0.199", auto_open=True, auto_close=True)  # Ion Pump
        self.tpg = TPG361(port='COM7')
        self.ig1 = instruments.DAQmxAnalogInput.DAQmxAnalogInput('USB-6009/ai0', minval=0.0, maxval=10.0)
        self.ig2 = instruments.DAQmxAnalogInput.DAQmxAnalogInput('USB-6009/ai1', minval=0.0, maxval=10.0)

        # Start updating GUI periodically
        self.timer_interval = 1000  # ms
        self.timer = QtCore.QTimer()
        self.timer.timeout.connect(self.update_status)
        self.timer.start(self.timer_interval)

    def mousePressEvent(self, event):
        self.start = self.mapToGlobal(event.pos())
        self.pressing = True

    def mouseMoveEvent(self, event):
        if self.pressing:
            self.end = self.mapToGlobal(event.pos())
            self.movement = self.end-self.start
            self.setGeometry(self.mapToGlobal(self.movement).x(),
                                self.mapToGlobal(self.movement).y(),
                                self.width(),
                                self.height())
            self.start = self.end

    def set_AlwaysOnTop(self, b):
        if b:
            self.setWindowFlags(self.windowFlags() | QtCore.Qt.WindowStaysOnTopHint)
        else:
            self.setWindowFlags(self.windowFlags() & ~QtCore.Qt.WindowStaysOnTopHint)

        self.show()

    def update_status(self):
        try:
            [ip1_v, ip1_i, ip1_p, ip2_v, ip2_i, ip2_p] = self.get_ion_pump_status()
            [ig1_p, ig2_p] = self.get_epimax_status()
            ll_p = self.get_pfeiffer_status()

            self.disp_IP1_voltage.setText('%.1f kV' % ip1_v)
            if ip1_i > 1000:
                self.disp_IP1_current.setText('%d mA' % (ip1_i/1e3))
            elif ip1_i > 1:
                self.disp_IP1_current.setText('%d \u03bcA' % ip1_i)
            else:
                self.disp_IP1_current.setText('%d nA' % (ip1_i*1e3))
            self.disp_IP1_pressure.setText('%.2e mbar' % ip1_p)

            self.disp_IP2_voltage.setText('%.1f kV' % ip2_v)
            if ip2_i > 1000:
                self.disp_IP2_current.setText('%d mA' % (ip2_i/1e3))
            elif ip2_i > 1:
                self.disp_IP2_current.setText('%d \u03bcA' % ip2_i)
            else:
                self.disp_IP2_current.setText('%d nA' % (ip2_i*1e3))
            self.disp_IP2_pressure.setText('%.2e mbar' % ip2_p)

            self.disp_IG1_pressure.setText('%.2e mbar' % ig1_p)
            self.disp_IG2_pressure.setText('%.2e mbar' % ig2_p)

            self.disp_LL_pressure.setText('%.2e mbar' % ll_p)

            # construct a binary record data
            now = datetime.datetime.now()
            stamp = time.mktime(now.timetuple())

            record = bytes()

            record += struct.pack('L', int(stamp))      # timestamp
            record += struct.pack('f', ig1_p)           # IG1 pressure (mbar)
            record += struct.pack('f', ig2_p)           # IG2 pressure (mbar)
            record += struct.pack('f', ll_p)            # LL pressure (mbar)
            record += struct.pack('f', ip1_p)           # IP1 pressure (mbar)
            record += struct.pack('f', ip1_i/1e6)       # IP1 current (A)
            record += struct.pack('i', int(ip1_v*1e3))  # IP1 voltage (V)
            record += struct.pack('f', ip2_p)           # IP2 pressure (mbar)
            record += struct.pack('f', ip2_i/1e6)       # IP2 current (A)
            record += struct.pack('i', int(ip2_v*1e3))  # IP2 voltage (V)

            log_path = os.path.expanduser(os.path.join('~', 'Documents', 'UHV Logs', 'System'))

            f = open(os.path.join(log_path, now.strftime('%Y-%m-%d.log')), 'ab')

            f.write(record)

            f.close()

        except TypeError:
            pass

    def get_ion_pump_status(self):
        readout = self.ion_pump.read_input_registers(0x0040, 40)

        # return Voltage (kV), Current (uA), Pressure (mbar) of the two pumps
        return [int(readout[0])/1e3, bits2float(readout[8:10])*1e6, bits2float(readout[24:26]),
                int(readout[1])/1e3, bits2float(readout[10:12])*1e6, bits2float(readout[26:28])]

    def get_pfeiffer_status(self):
        pressure, (status_code, status_string) = self.tpg.pressure_gauge()
        # unit = self.tpg.pressure_unit()
        if status_code == 0:
            # 1 - Underrange
            # 2 - Overrange
            # 3 - Sensor Error
            # 4 - Sensor Off
            # 5 - No Sensor
            # 6 - Identification Error
            return pressure
        else:
            if status_code == 1:
                return 1e-11
            else:
                return 1e3

    def get_epimax_status(self):
        v1 = self.ig1.get_voltages(1)[0]
        rmin1 = 1e-10
        rmax1 = 1e-3

        ig1_p = 10**(np.log10(rmin1) + v1 * (np.log10(rmax1/rmin1)/10))

        v2 = self.ig2.get_voltages(1)[0]
        rmin2 = 1e-10
        rmax2 = 1e-3

        ig2_p = 10**(np.log10(rmin2) + v2 * (np.log10(rmax2/rmin2)/10))

        return [ig1_p, ig2_p]

'''
Class Definition for Pfeiffer TPG361 Controller
'''


# Adapted from code from TPG26x that somehow did not work with python 3.5 due to string formatting
# Code translations constants
MEASUREMENT_STATUS = {
    0: 'Measurement data okay',
    1: 'Underrange',
    2: 'Overrange',
    3: 'Sensor error',
    4: 'Sensor off (IKR, PKR, IMR, PBR)',
    5: 'No sensor (output: 5,2.0000E-2 [mbar])',
    6: 'Identification error'
}
GAUGE_IDS = {
    'TPR': 'Pirani Gauge or Pirani Capacitive gauge',
    'IKR9': 'Cold Cathode Gauge 10E-9 ',
    'IKR11': 'Cold Cathode Gauge 10E-11 ',
    'PKR': 'FullRange CC Gauge',
    'PBR': 'FullRange BA Gauge',
    'IMR': 'Pirani / High Pressure Gauge',
    'CMR': 'Linear gauge',
    'noSEn': 'no SEnsor',
    'noid': 'no identifier'
}
PRESSURE_UNITS = {0: 'mbar', 1: 'Torr', 2: 'Pascal'}


class TPG361():
    """Class that implements the common driver for the
    TPG 361 single channel measurement and control unit.
    The driver implements the following 6 commands out the 39 in the specification:

    * PNR: Program number (firmware version)
    * PR[1,2]: Pressure measurement (measurement data) gauge [1, 2]
    * PRX: Pressure measurement (measurement data) gauge 1 and 2
    * TID: Transmitter identification (gauge identification)
    * UNI: Pressure unit
    * RST: RS232 test

    This class also contains the following class variables, for the specific
    characters that are used in the communication:

    :var ETX: End text (Ctrl-c), chr(3), \\x15
    :var CR: Carriage return, chr(13), \\r
    :var LF: Line feed, chr(10), \\n
    :var ENQ: Enquiry, chr(5), \\x05
    :var ACK: Acknowledge, chr(6), \\x06
    :var NAK: Negative acknowledge, chr(21), \\x15
    """

    ETX = chr(3)  # \x03
    CR = chr(13)
    LF = chr(10)
    ENQ = chr(5)  # \x05
    ACK = chr(6)  # \x06
    NAK = chr(21)  # \x15

    def __init__(self, port='COM7', baudrate=9600):
        """Initialize internal variables and serial connection

        :param port: The COM port to open. See the documentation for
            `pyserial <http://pyserial.sourceforge.net/>`_ for an explanation
            of the possible value. The default value is '/dev/ttyUSB0'.
        :type port: str or int
        :param baudrate: 9600, 19200, 38400 where 9600 is the default
        :type baudrate: int
        """
        # The serial connection should be setup with the following parameters:
        # 1 start bit, 8 data bits, No parity bit, 1 stop bit, no hardware
        # handshake. These are all default for Serial and therefore not input
        # below
        self.serial = serial.Serial(port=port, baudrate=baudrate, timeout=1)

    def _cr_lf(self, string):
        """Pad carriage return and line feed to a string

        :param string: String to pad
        :type string: str
        :returns: the padded string
        :rtype: str
        """
        return string + self.CR + self.LF

    def _send_command(self, command):
        """Send a command and check if it is positively acknowledged

        :param command: The command to send
        :type command: str
        :raises IOError: if the negative acknowledged or a unknown response
            is returned
        """
        self.serial.write(self._cr_lf(command).encode('utf-8'))
        response = self.serial.readline().decode('utf-8')
        if response == self._cr_lf(self.NAK):
            message = 'Serial communication returned negative acknowledge'
            raise IOError(message)
        elif response != self._cr_lf(self.ACK):
            message = 'Serial communication returned unknown response:\n{}' \
                      ''.format(repr(response))
            raise IOError(message)

    def _get_data(self):
        """Get the data that is ready on the device

        :returns: the raw data
        :rtype:str
        """
        self.serial.write(self.ENQ.encode('utf-8'))
        data = self.serial.readline().decode('utf-8')
        return data.rstrip(self.LF).rstrip(self.CR)

    def _clear_output_buffer(self):
        """Clear the output buffer"""
        time.sleep(0.1)
        just_read = 'start value'
        out = ''
        while just_read != '':
            just_read = self.serial.read()
            out += just_read
        return out

    def program_number(self):
        """Return the firmware version

        :returns: the firmware version
        :rtype: str
        """
        self._send_command('PNR')
        return self._get_data()

    def pressure_gauge(self, gauge=1):
        """Return the pressure measured by gauge X

        :param gauge: The gauge number, 1 or 2
        :type gauge: int
        :raises ValueError: if gauge is not 1 or 2
        :return: (value, (status_code, status_message))
        :rtype: tuple
        """
        if gauge not in [1, 2]:
            message = 'The input gauge number can only be 1 or 2'
            raise ValueError(message)
        self._send_command('PR' + str(gauge))
        reply = self._get_data()
        status_code = int(reply.split(',')[0])
        value = float(reply.split(',')[1])
        return value, (status_code, MEASUREMENT_STATUS[status_code])

    def gauge_identification(self):
        """Return the gauge identication

        :return: (id_code_1, id_1)
        :rtype: tuple
        """
        self._send_command('TID')
        reply = self._get_data()
        return reply

    def pressure_unit(self):
        """Return the pressure unit

        :return: the pressure unit
        :rtype: str
        """
        self._send_command('UNI')
        unit_code = int(self._get_data())
        return PRESSURE_UNITS[unit_code]

    def close(self):
        self.serial.close()


def main():
    """Packaged main function that launches GUI"""
    app = QtGui.QApplication(sys.argv)
    form = UHV_Gui()
    form.show()

    app.exec_()


if __name__ == '__main__':
    main()
