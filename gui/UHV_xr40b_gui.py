"""
The driver file for confocal_browser.py
confocal_browser.py should not be edited by the user
confocal_browser.ui is generated by Qt Designer, and not to be text-edited
"""

import sys
from PyQt5 import QtGui, QtCore
import pyqtgraph as pg
from pyModbusTCP.client import ModbusClient
from pyModbusTCP import utils
import numpy as np

# import ui files
import UHV_xr40b


# This thing reroute the exception handling such that it does not close the GUI when an exception is thrown in PyQt5
def my_excepthook(type, value, tback):
    sys.__excepthook__(type, value, tback)


sys.excepthook = my_excepthook


class XR40Bgui(QtGui.QMainWindow, UHV_xr40b.Ui_MainWindow):
    def __init__(self):
        # constructor from QMainWindow parent class
        super(self.__class__, self).__init__()
        # configure PyQTgraph to use white background
        pg.setConfigOption('background', 'w')
        pg.setConfigOption('foreground', 'k')
        # setupUi sits in exptdesign, as defined by Qt Designer
        self.setupUi(self)

        self.setFixedSize(self.size())
        self.setWindowFlags(QtCore.Qt.WindowCloseButtonHint | QtCore.Qt.WindowMinimizeButtonHint)
        self.setAttribute(QtCore.Qt.WA_DeleteOnClose)
        # this will ensure that the application quits at the right time,
        # and that Qt has a chance to automatically delete all the children of the top-level window
        # before the python garbage-collector gets to work.
        # http://stackoverflow.com/questions/27131294/error-qobjectstarttimer-qtimer-can-only-be-used-with-threads-started-with-qt

        # Connect to Device. Hard-coded the address for now
        self.xr40b_ec = ModbusClient(host="192.168.0.220", port=502, auto_open=True, auto_close=True)

        # Configure nice displays
        self.lcd_Uhv.setSmallDecimalPoint(True)
        self.lcd_Ie.setSmallDecimalPoint(True)

        # Load current status to display
        self.get_operate_stat()
        self.get_Uhv_setpoint()
        self.get_Ie_setpoint()

        # Connect the signals
        self.btn_operate.toggled[bool].connect(self.set_onoff)
        self.dbl_Uhv_setpoint.valueChanged.connect(self.set_Uhv)
        self.dbl_Ie_setpoint.valueChanged.connect(self.set_Ie)

        self.btn_Uhv_ramp.toggled[bool].connect(self.ramp_Uhv)
        self.btn_Uhv_hold.toggled[bool].connect(self.ramp_Uhv_hold)
        self.btn_Ie_ramp.toggled[bool].connect(self.ramp_Ie)
        self.btn_Ie_hold.toggled[bool].connect(self.ramp_Ie_hold)

        # Ramp timers
        self.timer_Uhv = QtCore.QTimer()
        self.timer_Uhv.timeout.connect(self.step_Uhv)
        self.Uhv_step_size = 0.1
        self.Uhv_ramp_up = True

        self.timer_Ie = QtCore.QTimer()
        self.timer_Ie.timeout.connect(self.step_Ie)
        self.Ie_step_size = 0.1
        self.Ie_ramp_up = True

        # Start updating GUI periodically
        self.timer_interval = 1000  # ms
        self.timer = QtCore.QTimer()
        self.timer.timeout.connect(self.update_status)
        self.timer.start(self.timer_interval)

    def update_status(self):
        self.get_Uhv()
        self.get_Ie()
        # todo: add Water cooling, cathode current, leakage current, etc

    def set_onoff(self, b):
        if b:
            self.xr40b_ec.write_multiple_registers(37, [1])
        else:
            self.xr40b_ec.write_multiple_registers(38, [1])

    def get_operate_stat(self):
        stat = self.xr40b_ec.read_holding_registers(1, 1)[0]
        self.btn_operate.setChecked(stat % 2)

    def get_Uhv(self):
        Uhv = self.xr40b_ec.read_holding_registers(5, 1)[0]
        self.lcd_Uhv.display(Uhv/1000)

    def get_Ie(self):
        Ie = bits2float(self.xr40b_ec.read_holding_registers(6, 2))
        self.lcd_Ie.display(Ie)

    def get_Uhv_setpoint(self):
        Uhv = self.xr40b_ec.read_holding_registers(41, 1)[0]
        self.dbl_Uhv_setpoint.setValue(Uhv/1000)

    def get_Ie_setpoint(self):
        Ie = bits2float(self.xr40b_ec.read_holding_registers(42, 2))
        self.dbl_Ie_setpoint.setValue(Ie)

    def set_Uhv(self, val):
        self.xr40b_ec.write_multiple_registers(41, [round(val*1000)])

    def set_Ie(self, val):
        self.xr40b_ec.write_multiple_registers(42, float2bits(val))

    def ramp_Uhv(self, b):
        if b:
            self.gui_enable_Uhv(False)
            # Calculate step time:
            start_val = self.dbl_Uhv_setpoint.value()
            end_val = self.dbl_Uhv_ramp_setpoint.value()
            self.Uhv_ramp_up = start_val < end_val
            ramp_time = self.dbl_Uhv_ramp_time.value()
            step_time = ramp_time/np.abs(end_val - start_val)*self.Uhv_step_size*60*1000  # ms
            self.timer_Uhv.start(step_time)
        else:
            if self.btn_Uhv_hold.isChecked():
                self.btn_Uhv_hold.setChecked(False)
            self.timer_Uhv.stop()
            self.gui_enable_Uhv(True)

    def step_Uhv(self):
        Uhv = self.dbl_Uhv_setpoint.value()
        if self.Uhv_ramp_up:
            if Uhv < self.dbl_Uhv_ramp_setpoint.value():
                self.dbl_Uhv_setpoint.setValue(Uhv + self.Uhv_step_size)
            else:
                self.btn_Uhv_ramp.setChecked(False)
        else:
            if Uhv > self.dbl_Uhv_ramp_setpoint.value():
                self.dbl_Uhv_setpoint.setValue(Uhv - self.Uhv_step_size)
            else:
                self.btn_Uhv_ramp.setChecked(False)

    def ramp_Uhv_hold(self, b):
        if b:
            self.timer_Uhv.stop()
        else:
            self.timer_Uhv.start()

    def gui_enable_Uhv(self, b):
        self.dbl_Uhv_setpoint.setEnabled(b)
        self.dbl_Uhv_ramp_setpoint.setEnabled(b)
        self.dbl_Uhv_ramp_time.setEnabled(b)
        self.btn_Uhv_hold.setEnabled(~b)

    def ramp_Ie(self, b):
        if b:
            self.gui_enable_Ie(False)
            # Calculate step time:
            start_val = self.dbl_Ie_setpoint.value()
            end_val = self.dbl_Ie_ramp_setpoint.value()
            self.Ie_ramp_up = start_val < end_val
            ramp_time = self.dbl_Ie_ramp_time.value()
            step_time = ramp_time/np.abs(end_val - start_val)*self.Ie_step_size*60*1000  # ms
            self.timer_Ie.start(step_time)
        else:
            if self.btn_Ie_hold.isChecked():
                self.btn_Ie_hold.setChecked(False)
            self.timer_Ie.stop()
            self.gui_enable_Ie(True)

    def step_Ie(self):
        Ie = self.dbl_Ie_setpoint.value()
        if self.Ie_ramp_up:
            if Ie < self.dbl_Ie_ramp_setpoint.value():
                self.dbl_Ie_setpoint.setValue(Ie + self.Ie_step_size)
            else:
                self.btn_Ie_ramp.setChecked(False)
        else:
            if Ie > self.dbl_Ie_ramp_setpoint.value():
                self.dbl_Ie_setpoint.setValue(Ie - self.Ie_step_size)
            else:
                self.btn_Ie_ramp.setChecked(False)

    def ramp_Ie_hold(self, b):
        if b:
            self.timer_Ie.stop()
        else:
            self.timer_Ie.start()

    def gui_enable_Ie(self, b):
        self.dbl_Ie_setpoint.setEnabled(b)
        self.dbl_Ie_ramp_setpoint.setEnabled(b)
        self.dbl_Ie_ramp_time.setEnabled(b)
        self.btn_Ie_hold.setEnabled(~b)


def num2bits(num):
    return [int(num / 65536), int(num % 65536)]


def bits2num(bits):
    return bits[0]*65536 + bits[1]


def float2bits(num):
    return num2bits(utils.encode_ieee(num))


def bits2float(bits):
    return utils.decode_ieee(bits2num(bits))


def main():
    """Packaged main function that launches GUI"""
    app = QtGui.QApplication(sys.argv)
    form = XR40Bgui()
    form.show()

    app.exec_()


if __name__ == '__main__':
    main()
