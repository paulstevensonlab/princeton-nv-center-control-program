"""
The driver file for confocal_browser.py
confocal_browser.py should not be edited by the user
confocal_browser.ui is generated by Qt Designer, and not to be text-edited
"""

import os
import sys
from PyQt5 import QtGui, QtCore
import pyqtgraph as pg
import struct
import time
import datetime
import instruments

# import ui files
import UHV_LakeShore


# This thing reroute the exception handling such that it does not close the GUI when an exception is thrown in PyQt5
def my_excepthook(type, value, tback):
    sys.__excepthook__(type, value, tback)


sys.excepthook = my_excepthook


class LakeShoreGUI(QtGui.QMainWindow, UHV_LakeShore.Ui_MainWindow):
    def __init__(self):
        # constructor from QMainWindow parent class
        super(self.__class__, self).__init__()
        # configure PyQTgraph to use white background
        pg.setConfigOption('background', 'w')
        pg.setConfigOption('foreground', 'k')
        # setupUi sits in exptdesign, as defined by Qt Designer
        self.setupUi(self)

        self.setFixedSize(self.size())
        self.setWindowFlags(QtCore.Qt.WindowCloseButtonHint | QtCore.Qt.WindowMinimizeButtonHint)
        self.setAttribute(QtCore.Qt.WA_DeleteOnClose)
        # this will ensure that the application quits at the right time,
        # and that Qt has a chance to automatically delete all the children of the top-level window
        # before the python garbage-collector gets to work.
        # http://stackoverflow.com/questions/27131294/error-qobjectstarttimer-qtimer-can-only-be-used-with-threads-started-with-qt

        # Connect to Device. Hard-coded the address for now
        self.dev = instruments.LakeShore.Model325('LakeShore')

        # Configure nice displays
        self.lcd_temp.setSmallDecimalPoint(True)
        self.lcd_output.setSmallDecimalPoint(True)
        self.cbox_heater_mode.addItems(['OFF', 'LOW', 'HIGH'])

        # Add pyqtgraph for temperature
        self.plt_temp = pg.PlotItem()
        self.plt_temp.setLabel('left', 'TEMP', units='C')
        self.plt_temp.setLabel('bottom', 'time (min)')
        font = QtGui.QFont()
        font.setPixelSize(20)
        self.plt_temp.getAxis('left').tickFont = font
        self.plt_temp.getAxis('bottom').tickFont = font
        # self.curve_temp_setpoint = self.plt_temp.plot([], [], pen=pg.mkPen(color=(255, 196, 196)))
        self.curve_temp = self.plt_temp.plot([], [], pen='r')

        self.glw_log.addItem(self.plt_temp)

        self.log_time = []
        self.log_temp = []
        self.log_temp_setpoint = []

        # Get the current settings
        self.dbl_setpoint.setValue(self.dev.get_temp_setpoint())
        self.cbox_heater_mode.setCurrentIndex(self.dev.get_heater_mode())

        # Connect the signals
        self.dbl_setpoint.valueChanged.connect(self.dev.set_temp_setpoint)
        self.cbox_heater_mode.currentIndexChanged.connect(self.dev.set_heater_mode)
        self.btn_log_clear.clicked.connect(self.clear_log)

        # Start updating GUI periodically
        self.clear_log()
        self.timer_interval = 1000  # ms
        self.timer = QtCore.QTimer()
        self.timer.timeout.connect(self.update_status)
        self.timer.start(self.timer_interval)

    def update_status(self):
        if self.log_time:
            self.log_time.append(self.log_time[-1]+self.timer_interval/60/1000)
        else:
            self.log_time.append(0)

        temp = self.dev.get_temp()
        setpoint = self.dev.get_temp_setpoint()
        output = self.dev.get_output()
        sensor = self.dev.get_sensor()
        mode = self.dev.get_heater_mode()

        self.lcd_temp.display(temp)
        self.lcd_output.display(output)

        self.log_temp.append(temp)
        self.log_temp_setpoint.append(setpoint)

        self.curve_temp.setData(self.log_time, self.log_temp)
        # self.curve_temp_setpoint.setData(self.log_time, self.log_temp_setpoint)

        self.label_time_stop.setText('End: ' + time.strftime('%A, %d %b %Y %H:%M:%S', time.localtime()))

        # construct a binary record data
        now = datetime.datetime.now()
        stamp = time.mktime(now.timetuple())

        record = bytes()

        record += struct.pack('L', int(stamp))  # timestamp
        record += struct.pack('f', temp)
        record += struct.pack('f', setpoint)
        record += struct.pack('f', output)
        record += struct.pack('f', sensor)
        record += struct.pack('i', mode)

        log_path = os.path.expanduser(os.path.join('~', 'Documents', 'UHV Logs', 'Experiments', 'LakeShore'))

        f = open(os.path.join(log_path, now.strftime('%Y-%m-%d.log')), 'ab')

        f.write(record)

        f.close()

    def clear_log(self):
        self.log_time = []
        self.log_temp = []
        self.log_temp_setpoint = []

        self.label_time_start.setText('Start: ' + time.strftime('%A, %d %b %Y %H:%M:%S', time.localtime()))


def main():
    """Packaged main function that launches GUI"""
    app = QtGui.QApplication(sys.argv)
    form = LakeShoreGUI()
    form.show()

    app.exec_()


if __name__ == '__main__':
    main()
