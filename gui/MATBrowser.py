"""
The driver file for confocal_browser.py
confocal_browser.py should not be edited by the user
confocal_browser.ui is generated by Qt Designer, and not to be text-edited
"""

import os
from os.path import *
import sys
import re
from PyQt5 import QtGui, QtCore, QtWidgets
import pyqtgraph as pg
import pandas as pd
# import ui files
import mat_browser


def my_excepthook(type, value, tback):
    sys.__excepthook__(type, value, tback)


sys.excepthook = my_excepthook


class AFMcrawler(QtWidgets.QMainWindow, mat_browser.Ui_MainWindow):
    def __init__(self):
        # constructor from QMainWindow parent class
        super(self.__class__,self).__init__()
        # configure PyQTgraph to use white background
        pg.setConfigOption('background', 'w')
        pg.setConfigOption('foreground', 'k')
        # setupUi sits in exptdesign, as defined by Qt Designer
        self.setupUi(self)
        self.setWindowIcon(QtGui.QIcon(os.path.join('gui', 'icons', 'jj.png')))

        self.setFixedSize(self.size())
        self.setWindowFlags(QtCore.Qt.WindowCloseButtonHint | QtCore.Qt.WindowMinimizeButtonHint)
        self.setAttribute(QtCore.Qt.WA_DeleteOnClose)
        # this will ensure that the application quits at the right time,
        # and that Qt has a chance to automatically delete all the children of the top-level window
        # before the python garbage-collector gets to work.
        # http://stackoverflow.com/questions/27131294/error-qobjectstarttimer-qtimer-can-only-be-used-with-threads-started-with-qt

        self.btnbrowse.clicked.connect(self.select_dir)

        self.table_afm.setColumnCount(2)
        self.table_afm.setColumnWidth(0, 120)
        self.table_afm.setHorizontalHeaderLabels(['Date', 'Sample'])
        self.table_afm.itemSelectionChanged.connect(self.select_afm_file)
        self.label_afm_img.setScaledContents(True)

        self.n_thumbs = 6

        for i in range(self.n_thumbs):
            setattr(self, 'thumbnail_%d' % i, ClickableLabel(''))
            self.grid_afm.addWidget(getattr(self, 'thumbnail_%d' % i), int(i/3), i % 3)
            getattr(self, 'thumbnail_%d' % i).setScaledContents(True)
            getattr(self, 'thumbnail_%d' % i).clicked.connect(self.disp_afm_image)

        self.table_xps.setColumnCount(5)
        self.table_xps.setColumnWidth(0, 120)
        self.table_xps.setColumnWidth(2, 200)
        self.table_xps.setColumnWidth(3, 120)
        self.table_xps.setColumnWidth(4, 50)
        self.table_xps.setHorizontalHeaderLabels(['Date', 'Sample', 'Description', 'Comments', 'Exp #'])
        self.table_xps.itemSelectionChanged.connect(self.select_xps_file)

        # Initialize XPS plot items
        for index, item in enumerate(['Survey', 'O1s', 'Si2p', 'C1s', 'Cl2p', 'Na1s', 'Other']):
            setattr(self, 'glw_xps_%s' % item, pg.GraphicsLayoutWidget())
            setattr(self, 'plt_xps_%s' % item, pg.PlotItem())
            setattr(self, 'curve_xps_%s' % item, getattr(self, 'plt_xps_%s' % item).plot([], [], pen='r'))
            getattr(self, 'plt_xps_%s' % item).invertX()

            if item == 'Survey':
                self.grid_xps_survey.addWidget(getattr(self, 'glw_xps_%s' % item), 0, 0)
            else:
                self.grid_xps_fine.addWidget(getattr(self, 'glw_xps_%s' % item), int((index-1)/3), (index-1) % 3)

            getattr(self, 'glw_xps_%s' % item).addItem(getattr(self, 'plt_xps_%s' % item))
            # getattr(self, 'glw_xps_%s' % item).hide()

    def select_dir(self):
        fd = QtGui.QFileDialog(directory=self.lineindir.text())
        targetdir = fd.getExistingDirectory()
        if targetdir != '':
            self.lineindir.setText(targetdir)

            self.table_afm.setRowCount(0)
            self.table_xps.setRowCount(0)

        self.dir_AFMdata(targetdir)
        self.dir_XPSdata(targetdir)

    def dir_AFMdata(self, directory):
        datapath = directory
        # todo: probably can write this as a recursion

        # Try to see if there is an exact match for year
        year_dirlist = sorted([f for f in os.listdir(datapath)
                               if re.match(r'\d\d\d\d', f) and not re.match(r'\d\d\d\d-\d\d-\d\d', f) and isdir(join(datapath, f))])

        if year_dirlist:
            # Dive into each year
            for year_dir in year_dirlist:
                self.dir_AFMdata_subdir(directory, year_dir)
        else:
            # We are already in YTD folder
            self.dir_AFMdata_subdir(directory)

    def dir_AFMdata_subdir(self, directory, subdir=''):
        if subdir:
            datapath = join(directory, subdir)
        else:
            datapath = directory

        date_dirlist = sorted([f for f in os.listdir(datapath)
                               if re.match(r'\d\d\d\d-\d\d-\d\d', f) and isdir(join(datapath, f))])

        for date_dir in date_dirlist:
            date_fullpath = join(datapath, date_dir)
            afm_dirlist = [f for f in os.listdir(date_fullpath) if 'AFM' in f and isdir(join(date_fullpath, f))]

            # Dive into AFM Directories
            afm_samplelist = []

            for afm_dir in afm_dirlist:
                # print(afm_dir)
                afm_fullpath = join(date_fullpath, afm_dir)

                afm_filelist = sorted([f for f in os.listdir(afm_fullpath)
                                       if re.fullmatch(r'\w*\.\d\d\d', f) and isfile(join(afm_fullpath, f))])

                for afm_file in afm_filelist:
                    [samplename, scan_num] = afm_file.split('.')
                    afm_samplelist.append(samplename)

            for samplename in sorted(set(afm_samplelist)):
                numrows = self.table_afm.rowCount()
                self.table_afm.setRowCount(numrows+1)
                if subdir:
                    self.table_afm.setItem(numrows, 0, QtGui.QTableWidgetItem(join(subdir, date_dir)))
                else:
                    self.table_afm.setItem(numrows, 0, QtGui.QTableWidgetItem(date_dir))
                self.table_afm.setItem(numrows, 1, QtGui.QTableWidgetItem(samplename))

    def select_afm_file(self):
        self.clear_afm_images()
        row = self.table_afm.currentRow()

        directory = self.lineindir.text()

        date = self.table_afm.item(row, 0).text()
        samplename = self.table_afm.item(row, 1).text()

        date_fullpath = join(directory, date)

        # Do a search through an entire directory. This is slower but should guarantee no crash.
        afm_dirlist = [f for f in os.listdir(date_fullpath) if 'AFM' in f and isdir(join(date_fullpath, f))]

        # Dive into AFM Directories and find any images that matches sample name
        afm_imagelist = []

        for afm_dir in afm_dirlist:
            afm_fullpath = join(date_fullpath, afm_dir)
            afm_filelist = sorted([f for f in os.listdir(afm_fullpath)
                                   if re.fullmatch(re.escape(samplename) + r'\.\d\d\d.png', f) and isfile(join(afm_fullpath, f))])

            for afm_file in sorted(afm_filelist):
                afm_imagelist.append(join(afm_fullpath, afm_file))

        for index, imageloc in enumerate(afm_imagelist):
            if index < self.n_thumbs:
                getattr(self, 'thumbnail_%d' % index).setImage(imageloc)
            else:
                raise RuntimeError('Only %d AFM images supported in the current version.' % self.n_thumbs)

    def clear_afm_images(self):
        for i in range(self.n_thumbs):
            getattr(self, 'thumbnail_%d' % i).clear()
        self.label_afm_filename.clear()
        self.label_afm_img.clear()

    def disp_afm_image(self, imageloc):
        self.label_afm_filename.setText(imageloc)
        self.label_afm_img.setPixmap(QtGui.QPixmap(imageloc))

    def dir_XPSdata(self, directory):
        datapath = directory
        # todo: probably can write this as a recursion

        # Try to see if there is an exact match for year
        year_dirlist = sorted([f for f in os.listdir(datapath)
                               if re.match(r'\d\d\d\d', f) and not re.match(r'\d\d\d\d-\d\d-\d\d', f) and isdir(join(datapath, f))])

        if year_dirlist:
            # Dive into each year
            for year_dir in year_dirlist:
                self.dir_XPSdata_subdir(directory, year_dir)
        else:
            # We are already in YTD folder
            self.dir_XPSdata_subdir(directory)

    def dir_XPSdata_subdir(self, directory, subdir=''):
        if subdir:
            datapath = join(directory, subdir)
        else:
            datapath = directory

        date_dirlist = sorted([f for f in os.listdir(datapath)
                               if re.match(r'\d\d\d\d-\d\d-\d\d', f) and isdir(join(datapath, f))])

        for date_dir in date_dirlist:
            date_fullpath = join(datapath, date_dir)
            xps_filelist = [f for f in os.listdir(date_fullpath) if 'XPS' in f and isfile(join(date_fullpath, f))]

            # Dive into XPS Directories
            for xps_file in xps_filelist:
                if not ('.xls' in xps_file or '.xlsx' in xps_file):
                    print('File format not supported yet: %s' % xps_file)
                else:
                    xps_fullpath = join(date_fullpath, xps_file)

                    date = re.search(r'\d\d\d\d-\d\d-\d\d', xps_file).group(0)

                    try:
                        _excelfile = pd.ExcelFile(join(date_fullpath, xps_file))

                        try:
                            # get the suffixes
                            _experiments_suffix = sorted(
                                [e.split('Experiment')[1] for e in _excelfile.sheet_names if 'Experiment' in e])

                            # 'Experiment' sheet alone should have all the details regarding the sample
                            _exp_summary = _excelfile.parse('Experiment')

                            _exp_comments = _exp_summary.iat[2, 1]

                            for i, e in enumerate(_experiments_suffix):
                                _sample_name = _exp_summary.iat[5 + 2 * i, 1]
                                _sample_description = _exp_summary.iat[6 + 2 * i, 1]

                                numrows = self.table_xps.rowCount()
                                self.table_xps.setRowCount(numrows + 1)
                                if subdir:
                                    self.table_xps.setItem(numrows, 0, QtGui.QTableWidgetItem(join(subdir, date_dir)))
                                else:
                                    self.table_xps.setItem(numrows, 0, QtGui.QTableWidgetItem(date_dir))
                                self.table_xps.setItem(numrows, 1, QtGui.QTableWidgetItem(str(_sample_name)))
                                self.table_xps.setItem(numrows, 2, QtGui.QTableWidgetItem(str(_exp_comments)))
                                self.table_xps.setItem(numrows, 3, QtGui.QTableWidgetItem(str(_sample_description)))
                                self.table_xps.setItem(numrows, 4, QtGui.QTableWidgetItem(e))
                        except:
                            print('Error Reading Experiment: %s' % xps_file)
                    except:
                        print('Error! Not an excel file: %s' % xps_file)

    def select_xps_file(self):
        self.clear_xps_images()
        row = self.table_xps.currentRow()

        directory = self.lineindir.text()

        date = self.table_xps.item(row, 0).text()
        samplename = self.table_xps.item(row, 1).text()
        _scan_suffix = self.table_xps.item(row, 4).text()

        date_fullpath = join(directory, date)

        # Find an xps file in the directory:
        xps_file = [f for f in os.listdir(date_fullpath) if 'XPS' in f and isfile(join(date_fullpath, f))]

        if len(xps_file) > 1:
            print('Warning: Multiple files found!')
            print(xps_file)

        xps_file = xps_file[0]

        if not ('.xls' in xps_file or '.xlsx' in xps_file):
            print('File format not supported yet: %s' % xps_file)
        else:
            # # Save these for actual display of the data
            _excelfile = pd.ExcelFile(join(date_fullpath, xps_file))

            # _experiments = sorted([e.split('Experiment')[1] for e in _excelfile.sheet_names if 'Experiment' in e])

            # Use dictionary with Experiments > Scans
            # This may be redundant since we only need to look for one sample. But it shouldn't take too long.
            _scans = {}  #dict(zip(_experiments, [{}] * len(_experiments)))

            # look for survey scans
            for e in _excelfile.sheet_names:
                if 'Survey' in e and e.split('Survey')[1] == _scan_suffix:
                   _scans['Survey'] = _excelfile.parse(e, skiprows=16, usecols=[0, 2]).as_matrix()
                if ' Scan' in e and e.split(' Scan')[1] == _scan_suffix:
                    _scans[e.split(' Scan')[0]] = _excelfile.parse(e, skiprows=16, usecols=[0, 2]).as_matrix()
            self.plot_xps_data(_scans)

        self.label_xps_filename.setText(join(date_fullpath, xps_file))

    def plot_xps_data(self, data):
        for s in data.keys():
            if s in ['Survey', 'O1s', 'Si2p', 'C1s', 'Cl2p', 'Na1s']:
                # getattr(self, 'glw_xps_%s' % s).show()
                getattr(self, 'curve_xps_%s' % s).setData(data[s])
                getattr(self, 'plt_xps_%s' % s).setLabels(title='%s Scan' % s, bottom='Binding Energy (eV)')
            else:
                self.glw_xps_Other.show()
                self.curve_xps_Other.setData(data[s])
                self.plt_xps_Other.setLabels(title='%s Scan' % s, bottom='Binding Energy (eV)')

    def clear_xps_images(self):
        for s in ['Survey', 'O1s', 'Si2p', 'C1s', 'Cl2p', 'Na1s', 'Other']:
            getattr(self, 'curve_xps_%s' % s).setData([], [])
            # getattr(self, 'glw_xps_%s' % s).hide()


class ClickableLabel(QtGui.QLabel):
    clicked = QtCore.Signal(str)

    def __init__(self, labelname):
        super().__init__(labelname)
        self.imageloc = ''

    def mousePressEvent(self, event):
        self.clicked.emit(self.imageloc)

    def setImage(self, imageloc):
        self.setPixmap(QtGui.QPixmap(imageloc))
        self.imageloc = imageloc

    def clear(self):
        super().clear()
        self.imageloc = ''

def main():
    """Packaged main function that launches GUI"""
    app = QtGui.QApplication(sys.argv)
    form = AFMcrawler()
    form.show()
    # form.chkbox_tracktime.setChecked(False)
    # form.chkboxsave.setChecked(False)

    app.exec_()


if __name__ == '__main__':
    main()
