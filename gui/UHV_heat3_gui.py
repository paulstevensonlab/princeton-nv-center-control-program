"""
The driver file for confocal_browser.py
confocal_browser.py should not be edited by the user
confocal_browser.ui is generated by Qt Designer, and not to be text-edited
"""

import os
import sys
from PyQt5 import QtGui, QtCore
import pyqtgraph as pg
from pyModbusTCP.client import ModbusClient
import numpy as np
import csv
import time
import datetime
import struct
from scipy.interpolate import interp1d

# import ui files
import UHV_heat3


# This thing reroute the exception handling such that it does not close the GUI when an exception is thrown in PyQt5
def my_excepthook(type, value, tback):
    sys.__excepthook__(type, value, tback)


sys.excepthook = my_excepthook

heater_cal_res_Tsystem = [0.0,
                          47.42833399417935,
                          96.91552379582787,
                          128.34995011007504,
                          165.11906019246914,
                          203.98989093396386,
                          244.5886236411941,
                          287.9213904304323,
                          338.4073407931962,
                          386.31692578123716,
                          418.2075571120794,
                          443.7789133407567,
                          464.24239648761954,
                          478.32822077161734,
                          492.2791858395197,
                          506.56940486432114,
                          522.3220355622975,
                          536.9861318092874,
                          551.343897201475,
                          566.2110565992388,
                          581.0449617744472,
                          597.5140519876679,
                          610.8881574194857,
                          624.3855788161494,
                          637.5910164180564,
                          650.6458954377343,
                          700]

heater_cal_res_Tsample = [0.0,
                          47.80415871390248,
                          136.04185141881658,
                          208.8325508678716,
                          286.9878202093586,
                          372.0430841748996,
                          437.86042023639556,
                          499.7930852682268,
                          554.1072768956277,
                          600.9567143880204,
                          643.7577222175368,
                          678.3199187961103,
                          705.3765771023292,
                          730.1939786004301,
                          753.6151287290426,
                          776.223669499261,
                          801.2171896025785,
                          821.583011367125,
                          842.777150755169,
                          862.6498980555252,
                          882.4689240873901,
                          900.3564634975705,
                          916.321723105815,
                          929.9773319220164,
                          942.5257666703004,
                          954.7039361711054,
                          1000]

heater_cal_eb_Tsystem = [0.0,
                         30.92996949,
                         73.10312096,
                         93.27675843,
                         111.01501471,
                         128.0952991,
                         147.18027139,
                         167.16111002,
                         187.46229875,
                         208.32596992,
                         230.75680681,
                         253.99560968,
                         279.17960915,
                         303.52520035,
                         329.49769818,
                         357.54932799,
                         385.10285867,
                         414.31274473,
                         449.36948128,
                         475.24409964,
                         500.48709898,
                         539.72153662,
                         603.16831647,
                         678.41612876,
                         792.30859839,
                         918.70984162]

heater_cal_eb_Tsample = [0.0,
                         32.02133236,
                         79.62111168,
                         129.65742506,
                         171.19930018,
                         214.16991851,
                         251.73639231,
                         290.97131762,
                         336.25507836,
                         376.16511354,
                         413.64333667,
                         453.42309618,
                         491.24180959,
                         530.4147321,
                         572.69291978,
                         612.5103318,
                         650.18323739,
                         687.44790531,
                         732.72714278,
                         775.15494215,
                         827.85688437,
                         914.29561265,
                         1029.75702186,
                         1179.40720314,
                         1362.93792894,
                         1439.34211604]

heater_cal_interpolator_res_sys2sam = interp1d(heater_cal_res_Tsystem, heater_cal_res_Tsample)
heater_cal_interpolator_res_sam2sys = interp1d(heater_cal_res_Tsample, heater_cal_res_Tsystem)

heater_cal_interpolator_eb_sys2sam = interp1d(heater_cal_eb_Tsystem, heater_cal_eb_Tsample)
heater_cal_interpolator_eb_sam2sys = interp1d(heater_cal_eb_Tsample, heater_cal_eb_Tsystem)


class HEAT3gui(QtGui.QMainWindow, UHV_heat3.Ui_MainWindow):
    def __init__(self):
        # constructor from QMainWindow parent class
        super(self.__class__,self).__init__()
        # configure PyQTgraph to use white background
        pg.setConfigOption('background', 'w')
        pg.setConfigOption('foreground', 'k')
        # setupUi sits in exptdesign, as defined by Qt Designer
        self.setupUi(self)

        self.setFixedSize(self.size())
        self.setWindowFlags(QtCore.Qt.WindowCloseButtonHint | QtCore.Qt.WindowMinimizeButtonHint)
        self.setAttribute(QtCore.Qt.WA_DeleteOnClose)
        # this will ensure that the application quits at the right time,
        # and that Qt has a chance to automatically delete all the children of the top-level window
        # before the python garbage-collector gets to work.
        # http://stackoverflow.com/questions/27131294/error-qobjectstarttimer-qtimer-can-only-be-used-with-threads-started-with-qt

        # Connect to Device. Hard-coded the address for now
        self.heat3_ps = ModbusClient(host="192.168.0.203", port=1025, auto_open=True, auto_close=True)

        # Configure nice displays
        self.lcd_temp.setSmallDecimalPoint(True)
        self.lcd_temp_2.setSmallDecimalPoint(True)
        self.lcd_temp_pid.setSmallDecimalPoint(True)
        self.lcd_Ic.setSmallDecimalPoint(True)
        self.lcd_Uc.setSmallDecimalPoint(True)
        self.lcd_Ie.setSmallDecimalPoint(True)
        self.lcd_Ue.setSmallDecimalPoint(True)

        self.radio_heat_mode = QtGui.QButtonGroup()
        self.radio_heat_mode.addButton(self.radio_res, 0)
        self.radio_heat_mode.addButton(self.radio_eb, 1)
        self.radio_oper_mode = QtGui.QButtonGroup()
        self.radio_oper_mode.addButton(self.radio_manual, 0)
        self.radio_oper_mode.addButton(self.radio_auto, 1)
        self.radio_temp_mode = QtGui.QButtonGroup()
        self.radio_temp_mode.addButton(self.radio_tsystem, 0)
        self.radio_temp_mode.addButton(self.radio_tsample, 1)

        self.set_pid_params()
        self.set_ramp_units()
        self.get_temp_ramp()
        self.get_heat_mode()
        self.get_oper_mode()
        self.dbl_temp_setpoint_system.setValue(self.get_temp_setpoint())
        self.get_Ic_setpoint()
        self.get_Ue_setpoint()

        # Initialize arrays for data logging
        self.log_time = []
        self.log_temp = []
        self.log_temp_setpoint = []
        self.log_temp_sample = []
        self.log_Ic = []
        self.log_Uc = []
        self.log_Ie = []
        self.log_Ue = []
        self.label_time.setText('Start: ' + time.strftime('%A, %d %b %Y %H:%M:%S', time.localtime()))

        self.plt_temp = pg.PlotItem()
        self.plt_filament = pg.PlotItem()
        self.plt_ebeam = pg.PlotItem()

        self.plt_temp.getViewBox().setXLink(self.plt_ebeam.getViewBox())
        self.plt_temp.hideAxis('bottom')
        self.plt_filament.getViewBox().setXLink(self.plt_ebeam.getViewBox())
        self.plt_filament.hideAxis('bottom')

        self.curve_temp_setpoint = self.plt_temp.plot([], [], pen=pg.mkPen(color=(255, 196, 196)))
        self.curve_temp = self.plt_temp.plot([], [], pen='r')
        self.curve_temp_sample = self.plt_temp.plot([], [], pen='b')
        self.curve_Uc = self.plt_filament.plot([], [], pen='b')
        self.curve_Ic = self.plt_filament.plot([], [], pen='r')
        self.curve_Ie = self.plt_ebeam.plot([], [], pen='r')
        self.curve_Ue = self.plt_ebeam.plot([], [], pen='b')

        self.glw_log.addItem(self.plt_temp, 0, 0)
        self.glw_log.addItem(self.plt_filament, 1, 0)
        self.glw_log.addItem(self.plt_ebeam, 2, 0)

        self.plt_temp.setLabel('left', 'TEMP', units='C')
        self.plt_filament.setLabel('left', 'Ic (A), Uc (V)')
        self.plt_ebeam.setLabel('left', 'Ie (mA), Ue (V)')
        self.plt_ebeam.setLabel('bottom', 'time (min)')

        self.update_status()
        self.set_gui_controls()

        # Connect the signals
        self.radio_temp_mode.buttonClicked[int].connect(self.set_temp_mode)
        self.radio_tsystem.setChecked(True)
        self.set_temp_mode(0)
        self.radio_heat_mode.buttonClicked[int].connect(self.set_heat_mode)
        self.radio_oper_mode.buttonClicked[int].connect(self.set_oper_mode)
        self.btn_operate.toggled[bool].connect(self.set_onoff)
        self.dbl_temp_setpoint_system.valueChanged.connect(self.set_temp_setpoint_system)  # todo: change to finish editing
        self.dbl_temp_setpoint_sample.valueChanged.connect(self.set_temp_setpoint_sample)
        self.dbl_temp_ramp.valueChanged.connect(self.set_temp_ramp)
        self.dbl_Ic_setpoint.valueChanged.connect(self.set_Ic)
        self.dbl_Ue_setpoint.valueChanged.connect(self.set_Ue)
        self.btn_Ic_ramp.toggled[bool].connect(self.ramp_Ic)
        self.btn_Ic_hold.toggled[bool].connect(self.ramp_Ic_hold)
        self.btn_Ue_ramp.toggled[bool].connect(self.ramp_Ue)
        self.btn_Ue_hold.toggled[bool].connect(self.ramp_Ue_hold)
        self.btn_log_export.clicked.connect(self.export_log)
        self.btn_log_clear.clicked.connect(self.clear_log)

        # Ramp timers
        self.timer_Ic = QtCore.QTimer()
        self.timer_Ic.timeout.connect(self.step_Ic)
        self.Ic_step_size = 0.01
        self.Ic_ramp_up = True

        self.timer_Ue = QtCore.QTimer()
        self.timer_Ue.timeout.connect(self.step_Ue)
        self.Ue_step_size = 0.1
        self.Ue_ramp_up = False

        # Start updating GUI periodically
        self.timer_interval = 1000  # ms
        self.timer = QtCore.QTimer()
        self.timer.timeout.connect(self.update_status)
        self.timer.start(self.timer_interval)

    def update_status(self):
        self.get_status()
        self.log()
        self.label_time_2.setText('End: ' + time.strftime('%A, %d %b %Y %H:%M:%S', time.localtime()))

    def set_onoff(self, b):
        if b:
            self.heat3_ps.write_multiple_registers(70, [1])
        else:
            self.heat3_ps.write_multiple_registers(71, [1])

    def set_temp_mode(self, i):
        self.dbl_temp_setpoint_system.setVisible(not bool(i))
        self.dbl_temp_setpoint_system.setEnabled(not bool(i))
        self.dbl_temp_setpoint_sample.setVisible(bool(i))
        self.dbl_temp_setpoint_sample.setEnabled(bool(i))

    def set_heat_mode(self, i):
        self.heat3_ps.write_multiple_registers(22, [i])
        self.set_gui_controls()

    def set_oper_mode(self, i):
        self.heat3_ps.write_multiple_registers(21, [i])
        self.get_oper_mode()
        self.set_gui_controls()

    def set_temp_setpoint_system(self, temp):
        self.heat3_ps.write_multiple_registers(14, num2bits((temp+273.15)*100))

    def set_temp_setpoint_sample(self, temp):
        if self.radio_res.isChecked():
            self.heat3_ps.write_multiple_registers(14, num2bits((heater_cal_interpolator_res_sam2sys(temp)+273.15)*100))
        else:
            self.heat3_ps.write_multiple_registers(14, num2bits((heater_cal_interpolator_eb_sam2sys(temp)+273.15)*100))

    def set_pid_params(self):
        p = 20
        i = 3
        d = 0
        self.heat3_ps.write_multiple_registers(45, [int(p), int(i), int(d)])

    def set_ramp_units(self):
        # 0 - unit/s
        # 1 - unit/min
        # 2 - unit/hr
        u = 1
        self.heat3_ps.write_multiple_registers(44, [u])

    def set_temp_ramp(self, ramp_per_min):
        self.heat3_ps.write_multiple_registers(43, [int(ramp_per_min*10)])

    def get_temp_ramp(self):
        self.dbl_temp_ramp.setValue(self.heat3_ps.read_holding_registers(43, 1)[0]/10.0)

    def get_status(self):
        stat = self.heat3_ps.read_holding_registers(0, 1)[0]

        # bit0: Device state: 0 - STANDBY, 1 - OPERATE
        # bit1: DC module type: 0 - constatnt current, 1 - constant voltage
        # bit2: Autotune: 0 - Off, 1 - On
        # bit3: Channel TC1 - no thermocouple
        # bit4: Channel TC2 - no thermocouple
        # bit5: Channel D1 - no diode
        # bit6: Channel D2 - no diode
        # bit7: Channel RTD - no sensor

        self.btn_operate.setChecked(stat % 2)

    def get_temp(self):
        temp = round((bits2num(self.heat3_ps.read_holding_registers(4, 2)) - 27315)/10)/10
        self.lcd_temp.display(temp)
        return temp

    def get_temp_sample(self):
        if self.radio_res.isChecked():
            temp = heater_cal_interpolator_res_sys2sam(round((bits2num(self.heat3_ps.read_holding_registers(4, 2)) - 27315)/10)/10)
        else:
            temp = heater_cal_interpolator_eb_sys2sam(round((bits2num(self.heat3_ps.read_holding_registers(4, 2)) - 27315)/10)/10)
        self.lcd_temp_2.display(temp)
        return temp

    def get_heat_mode(self):
        if self.heat3_ps.read_holding_registers(22, 1)[0]:
            self.radio_eb.setChecked(True)
        else:
            self.radio_res.setChecked(True)

    def get_oper_mode(self):
        if self.heat3_ps.read_holding_registers(21, 1)[0]:
            self.radio_auto.setChecked(True)
        else:
            self.radio_manual.setChecked(True)

    def get_temp_setpoint(self):
        temp = round((bits2num(self.heat3_ps.read_holding_registers(14, 2)) - 27315)/10)/10
        self.lcd_temp_pid.display(temp)
        return temp

    def set_gui_controls(self):
        oper_auto = self.radio_auto.isChecked()
        mode_eb = self.radio_eb.isChecked()

        self.dbl_temp_setpoint_system.setValue(self.get_temp_setpoint())
        self.dbl_Ic_setpoint.setEnabled(not oper_auto or mode_eb)
        self.groupBox_Ue.setVisible(mode_eb)
        self.label_Ie.setVisible(mode_eb)
        self.label_Ue.setVisible(mode_eb)
        self.label_Ue_setpoint.setVisible(mode_eb)
        self.lcd_Ie.setVisible(mode_eb)
        self.lcd_Ue.setVisible(mode_eb)
        self.dbl_Ue_setpoint.setVisible(mode_eb)
        self.dbl_Ue_setpoint.setEnabled(not oper_auto and mode_eb)

    def set_Ic(self, Ic):
        self.heat3_ps.write_multiple_registers(58, [int(Ic*100)])

    def set_Ue(self, Ue):
        self.heat3_ps.write_multiple_registers(61, [int(Ue*10)])

    def get_Ic_setpoint(self):
        Ic = self.heat3_ps.read_holding_registers(58, 1)[0]/100
        Ic = self.heat3_ps.read_holding_registers(58, 1)[0]/100
        self.dbl_Ic_setpoint.setValue(Ic)
        return Ic

    def get_Ic(self):
        Ic = self.heat3_ps.read_holding_registers(59, 1)[0]/100
        self.lcd_Ic.display(Ic)
        return Ic

    def get_Uc(self):
        Uc = self.heat3_ps.read_holding_registers(60, 1)[0]/10
        self.lcd_Uc.display(Uc)
        return Uc

    def get_Ie(self):
        Ie = self.heat3_ps.read_holding_registers(63, 1)[0]/1000
        self.lcd_Ie.display(Ie)
        return Ie

    def get_Ue_setpoint(self):
        Ue = self.heat3_ps.read_holding_registers(61, 1)[0]/10
        self.dbl_Ue_setpoint.setValue(Ue)
        return Ue

    def get_Ue(self):
        Ue = self.heat3_ps.read_holding_registers(62, 1)[0]/10
        self.lcd_Ue.display(Ue)
        return Ue

    def ramp_Ic(self, b):
        if b:
            self.gui_enable_Ic(False)
            # Calculate step time:
            start_val = self.dbl_Ic_setpoint.value()
            end_val = self.dbl_Ic_ramp_setpoint.value()
            self.Ic_ramp_up = start_val < end_val
            ramp_time = self.dbl_Ic_ramp_time.value()
            step_time = ramp_time/np.abs(end_val - start_val)*self.Ic_step_size*60*1000  # ms
            self.timer_Ic.start(step_time)
        else:
            if self.btn_Ic_hold.isChecked():
                self.btn_Ic_hold.setChecked(False)
            self.timer_Ic.stop()
            self.gui_enable_Ic(True)

    def step_Ic(self):
        Ic = self.dbl_Ic_setpoint.value()
        if self.Ic_ramp_up:
            if Ic < self.dbl_Ic_ramp_setpoint.value():
                self.dbl_Ic_setpoint.setValue(Ic + self.Ic_step_size)
            else:
                self.btn_Ic_ramp.setChecked(False)
        else:
            if Ic > self.dbl_Ic_ramp_setpoint.value():
                self.dbl_Ic_setpoint.setValue(Ic - self.Ic_step_size)
            else:
                self.btn_Ic_ramp.setChecked(False)

    def ramp_Ic_hold(self, b):
        if b:
            self.timer_Ic.stop()
        else:
            self.timer_Ic.start()

    def gui_enable_Ic(self, b):
        self.dbl_Ic_setpoint.setEnabled(b)
        self.dbl_Ic_ramp_setpoint.setEnabled(b)
        self.dbl_Ic_ramp_time.setEnabled(b)
        self.btn_Ic_hold.setEnabled(~b)

    def ramp_Ue(self, b):
        if b:
            self.gui_enable_Ue(False)
            # Calculate step time:
            start_val = self.dbl_Ue_setpoint.value()
            end_val = self.dbl_Ue_ramp_setpoint.value()
            self.Ue_ramp_up = start_val < end_val
            ramp_time = self.dbl_Ue_ramp_time.value()
            step_time = ramp_time/np.abs(end_val - start_val)*self.Ue_step_size*60*1000  # ms
            self.timer_Ue.start(step_time)
        else:
            if self.btn_Ue_hold.isChecked():
                self.btn_Ue_hold.setChecked(False)
            self.timer_Ue.stop()
            self.gui_enable_Ue(True)

    def step_Ue(self):
        Ue = self.dbl_Ue_setpoint.value()
        if self.Ue_ramp_up:
            if Ue < self.dbl_Ue_ramp_setpoint.value():
                self.dbl_Ue_setpoint.setValue(Ue + self.Ue_step_size)
            else:
                self.btn_Ue_ramp.setChecked(False)
        else:
            if Ue > self.dbl_Ue_ramp_setpoint.value():
                self.dbl_Ue_setpoint.setValue(Ue - self.Ue_step_size)
            else:
                self.btn_Ue_ramp.setChecked(False)

    def ramp_Ue_hold(self, b):
        if b:
            self.timer_Ue.stop()
        else:
            self.timer_Ue.start()

    def gui_enable_Ue(self, b):
        self.dbl_Ue_setpoint.setEnabled(b)
        self.dbl_Ue_ramp_setpoint.setEnabled(b)
        self.dbl_Ue_ramp_time.setEnabled(b)
        self.btn_Ue_hold.setEnabled(~b)

    def log(self):
        if self.log_time:
            self.log_time.append(self.log_time[-1]+self.timer_interval/60/1000)
        else:
            self.log_time.append(0)

        for item in ['temp', 'temp_setpoint', 'temp_sample', 'Ic', 'Uc', 'Ie', 'Ue']:
            data = getattr(self, 'log_%s' % item)
            if item is 'temp_setpoint' and not self.radio_auto.isChecked():
                data.append(np.NaN)
            else:
                data.append(getattr(self, 'get_%s' % item)())
            getattr(self, 'curve_%s' % item).setData(self.log_time, data)

        # construct a binary record data
        now = datetime.datetime.now()
        stamp = time.mktime(now.timetuple())

        record = bytes()

        record += struct.pack('L', int(stamp))                              # timestamp
        record += struct.pack('?', bool(self.btn_operate.isChecked()))      # On/Off
        record += struct.pack('?', bool(self.radio_eb.isChecked()))         # E-beam/Resistive
        record += struct.pack('?', bool(self.radio_auto.isChecked()))       # Auto/Manual
        record += struct.pack('?', bool(self.radio_tsystem.isChecked()))    # Use Tsystem as feedback
        record += struct.pack('f', self.log_temp_setpoint[-1])
        record += struct.pack('f', self.log_temp[-1])
        record += struct.pack('f', self.log_temp_sample[-1])
        record += struct.pack('f', self.log_Ic[-1])
        record += struct.pack('f', self.log_Uc[-1])
        record += struct.pack('f', self.log_Ie[-1])
        record += struct.pack('f', self.log_Ue[-1])

        log_path = os.path.expanduser(os.path.join('~', 'Documents', 'UHV Logs', 'Experiments', 'HEAT3'))

        f = open(os.path.join(log_path, now.strftime('%Y-%m-%d.log')), 'ab')

        f.write(record)

        f.close()

    def clear_log(self):
        self.log_time = []
        self.log_temp = []
        self.log_temp_setpoint = []
        self.log_temp_sample = []
        self.log_Ic = []
        self.log_Uc = []
        self.log_Ie = []
        self.log_Ue = []
        self.label_time.setText('Start: ' + time.strftime('%A, %d %b %Y %H:%M:%S', time.localtime()))

    def export_log(self):
        documents_path = os.path.expanduser(os.path.join('~', 'Documents'))
        fd = QtGui.QFileDialog(directory=documents_path)
        fd.setAcceptMode(1)

        targetfile = fd.getSaveFileName(filter='csv file (*.csv)')
        if targetfile != '':
            array2csv([self.log_time, self.log_temp, self.log_temp_setpoint, self.log_temp_sample, self.log_Ic, self.log_Uc, self.log_Ie, self.log_Ue],
                         targetfile, header=['Time (min)', 'System Temp (C)', 'Temp Setpoint (C)', 'Sample Temp (C)', 'Ic (A)', 'Uc (V)', 'Ie (mA)', 'Ue (V)'],
                         fmt=['%.3f', '%.1f', '%.1f', '%.1f', '%.2f', '%.1f', '%.2f', '%.1f'])


def num2bits(num):
    return [int(num / 65536), int(num % 65536)]


def bits2num(bits):
    return bits[0]*65536 + bits[1]


def array2csv(arr, filename, header=None, fmt=None):
    if header is None or fmt is None:
        np.savetxt(filename, arr, fmt='%.3f', delimiter=',')
    else:
        if len(set(map(len, arr))) not in (0, 1):
            raise ValueError('Not all lists have same length!')

        if len(header) != len(arr):
            raise ValueError('Header and data have different lengths!')

        if len(header) != len(fmt):
            raise ValueError('Header and Format have different lengths!')

        numcols = len(arr)
        numrows = len(arr[0])

        with open(filename, 'wt', newline='') as csvfile:
            writer = csv.writer(csvfile)
            # write header first
            writer.writerow(iter(header))

            for row in range(numrows):
                row2write = []
                for col in range(numcols):
                    item = arr[col][row]
                    row2write.append(fmt[col] % item)

                writer.writerow(iter(row2write))


def main():
    """Packaged main function that launches GUI"""
    app = QtGui.QApplication(sys.argv)
    form = HEAT3gui()
    form.show()

    app.exec_()


if __name__ == '__main__':
    main()
